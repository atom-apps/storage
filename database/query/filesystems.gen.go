// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/atom-apps/storage/database/models"
)

func newFilesystem(db *gorm.DB, opts ...gen.DOOption) filesystem {
	_filesystem := filesystem{}

	_filesystem.filesystemDo.UseDB(db, opts...)
	_filesystem.filesystemDo.UseModel(&models.Filesystem{})

	tableName := _filesystem.filesystemDo.TableName()
	_filesystem.ALL = field.NewAsterisk(tableName)
	_filesystem.ID = field.NewUint64(tableName, "id")
	_filesystem.CreatedAt = field.NewTime(tableName, "created_at")
	_filesystem.UpdatedAt = field.NewTime(tableName, "updated_at")
	_filesystem.DeletedAt = field.NewField(tableName, "deleted_at")
	_filesystem.TenantID = field.NewUint64(tableName, "tenant_id")
	_filesystem.UserID = field.NewUint64(tableName, "user_id")
	_filesystem.Driver = field.NewString(tableName, "driver")
	_filesystem.Filename = field.NewString(tableName, "filename")
	_filesystem.Type = field.NewString(tableName, "type")
	_filesystem.ParentID = field.NewUint64(tableName, "parent_id")
	_filesystem.Status = field.NewString(tableName, "status")
	_filesystem.Mime = field.NewString(tableName, "mime")
	_filesystem.ShareUUID = field.NewString(tableName, "share_uuid")
	_filesystem.Metadata = field.NewBytes(tableName, "metadata")

	_filesystem.fillFieldMap()

	return _filesystem
}

type filesystem struct {
	filesystemDo filesystemDo

	ALL       field.Asterisk
	ID        field.Uint64 // ID
	CreatedAt field.Time   // 创建时间
	UpdatedAt field.Time   // 更新时间
	DeletedAt field.Field  // 删除时间
	TenantID  field.Uint64 // 租户ID
	UserID    field.Uint64 // 用户ID
	Driver    field.String // 驱动
	Filename  field.String // 文件名
	Type      field.String // 类型
	ParentID  field.Uint64 // 父级ID
	Status    field.String // 状态
	Mime      field.String // MIME
	ShareUUID field.String // 共享ID
	Metadata  field.Bytes  // 元数据

	fieldMap map[string]field.Expr
}

func (f filesystem) Table(newTableName string) *filesystem {
	f.filesystemDo.UseTable(newTableName)
	return f.updateTableName(newTableName)
}

func (f filesystem) As(alias string) *filesystem {
	f.filesystemDo.DO = *(f.filesystemDo.As(alias).(*gen.DO))
	return f.updateTableName(alias)
}

func (f *filesystem) updateTableName(table string) *filesystem {
	f.ALL = field.NewAsterisk(table)
	f.ID = field.NewUint64(table, "id")
	f.CreatedAt = field.NewTime(table, "created_at")
	f.UpdatedAt = field.NewTime(table, "updated_at")
	f.DeletedAt = field.NewField(table, "deleted_at")
	f.TenantID = field.NewUint64(table, "tenant_id")
	f.UserID = field.NewUint64(table, "user_id")
	f.Driver = field.NewString(table, "driver")
	f.Filename = field.NewString(table, "filename")
	f.Type = field.NewString(table, "type")
	f.ParentID = field.NewUint64(table, "parent_id")
	f.Status = field.NewString(table, "status")
	f.Mime = field.NewString(table, "mime")
	f.ShareUUID = field.NewString(table, "share_uuid")
	f.Metadata = field.NewBytes(table, "metadata")

	f.fillFieldMap()

	return f
}

func (f *filesystem) WithContext(ctx context.Context) IFilesystemDo {
	return f.filesystemDo.WithContext(ctx)
}

func (f filesystem) TableName() string { return f.filesystemDo.TableName() }

func (f filesystem) Alias() string { return f.filesystemDo.Alias() }

func (f filesystem) Columns(cols ...field.Expr) gen.Columns { return f.filesystemDo.Columns(cols...) }

func (f *filesystem) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := f.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (f *filesystem) fillFieldMap() {
	f.fieldMap = make(map[string]field.Expr, 14)
	f.fieldMap["id"] = f.ID
	f.fieldMap["created_at"] = f.CreatedAt
	f.fieldMap["updated_at"] = f.UpdatedAt
	f.fieldMap["deleted_at"] = f.DeletedAt
	f.fieldMap["tenant_id"] = f.TenantID
	f.fieldMap["user_id"] = f.UserID
	f.fieldMap["driver"] = f.Driver
	f.fieldMap["filename"] = f.Filename
	f.fieldMap["type"] = f.Type
	f.fieldMap["parent_id"] = f.ParentID
	f.fieldMap["status"] = f.Status
	f.fieldMap["mime"] = f.Mime
	f.fieldMap["share_uuid"] = f.ShareUUID
	f.fieldMap["metadata"] = f.Metadata
}

func (f filesystem) clone(db *gorm.DB) filesystem {
	f.filesystemDo.ReplaceConnPool(db.Statement.ConnPool)
	return f
}

func (f filesystem) replaceDB(db *gorm.DB) filesystem {
	f.filesystemDo.ReplaceDB(db)
	return f
}

type filesystemDo struct{ gen.DO }

type IFilesystemDo interface {
	gen.SubQuery
	Debug() IFilesystemDo
	WithContext(ctx context.Context) IFilesystemDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IFilesystemDo
	WriteDB() IFilesystemDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IFilesystemDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IFilesystemDo
	Not(conds ...gen.Condition) IFilesystemDo
	Or(conds ...gen.Condition) IFilesystemDo
	Select(conds ...field.Expr) IFilesystemDo
	Where(conds ...gen.Condition) IFilesystemDo
	Order(conds ...field.Expr) IFilesystemDo
	Distinct(cols ...field.Expr) IFilesystemDo
	Omit(cols ...field.Expr) IFilesystemDo
	Join(table schema.Tabler, on ...field.Expr) IFilesystemDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IFilesystemDo
	RightJoin(table schema.Tabler, on ...field.Expr) IFilesystemDo
	Group(cols ...field.Expr) IFilesystemDo
	Having(conds ...gen.Condition) IFilesystemDo
	Limit(limit int) IFilesystemDo
	Offset(offset int) IFilesystemDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IFilesystemDo
	Unscoped() IFilesystemDo
	Create(values ...*models.Filesystem) error
	CreateInBatches(values []*models.Filesystem, batchSize int) error
	Save(values ...*models.Filesystem) error
	First() (*models.Filesystem, error)
	Take() (*models.Filesystem, error)
	Last() (*models.Filesystem, error)
	Find() ([]*models.Filesystem, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Filesystem, err error)
	FindInBatches(result *[]*models.Filesystem, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*models.Filesystem) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IFilesystemDo
	Assign(attrs ...field.AssignExpr) IFilesystemDo
	Joins(fields ...field.RelationField) IFilesystemDo
	Preload(fields ...field.RelationField) IFilesystemDo
	FirstOrInit() (*models.Filesystem, error)
	FirstOrCreate() (*models.Filesystem, error)
	FindByPage(offset int, limit int) (result []*models.Filesystem, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IFilesystemDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (f filesystemDo) Debug() IFilesystemDo {
	return f.withDO(f.DO.Debug())
}

func (f filesystemDo) WithContext(ctx context.Context) IFilesystemDo {
	return f.withDO(f.DO.WithContext(ctx))
}

func (f filesystemDo) ReadDB() IFilesystemDo {
	return f.Clauses(dbresolver.Read)
}

func (f filesystemDo) WriteDB() IFilesystemDo {
	return f.Clauses(dbresolver.Write)
}

func (f filesystemDo) Session(config *gorm.Session) IFilesystemDo {
	return f.withDO(f.DO.Session(config))
}

func (f filesystemDo) Clauses(conds ...clause.Expression) IFilesystemDo {
	return f.withDO(f.DO.Clauses(conds...))
}

func (f filesystemDo) Returning(value interface{}, columns ...string) IFilesystemDo {
	return f.withDO(f.DO.Returning(value, columns...))
}

func (f filesystemDo) Not(conds ...gen.Condition) IFilesystemDo {
	return f.withDO(f.DO.Not(conds...))
}

func (f filesystemDo) Or(conds ...gen.Condition) IFilesystemDo {
	return f.withDO(f.DO.Or(conds...))
}

func (f filesystemDo) Select(conds ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Select(conds...))
}

func (f filesystemDo) Where(conds ...gen.Condition) IFilesystemDo {
	return f.withDO(f.DO.Where(conds...))
}

func (f filesystemDo) Order(conds ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Order(conds...))
}

func (f filesystemDo) Distinct(cols ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Distinct(cols...))
}

func (f filesystemDo) Omit(cols ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Omit(cols...))
}

func (f filesystemDo) Join(table schema.Tabler, on ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Join(table, on...))
}

func (f filesystemDo) LeftJoin(table schema.Tabler, on ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.LeftJoin(table, on...))
}

func (f filesystemDo) RightJoin(table schema.Tabler, on ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.RightJoin(table, on...))
}

func (f filesystemDo) Group(cols ...field.Expr) IFilesystemDo {
	return f.withDO(f.DO.Group(cols...))
}

func (f filesystemDo) Having(conds ...gen.Condition) IFilesystemDo {
	return f.withDO(f.DO.Having(conds...))
}

func (f filesystemDo) Limit(limit int) IFilesystemDo {
	return f.withDO(f.DO.Limit(limit))
}

func (f filesystemDo) Offset(offset int) IFilesystemDo {
	return f.withDO(f.DO.Offset(offset))
}

func (f filesystemDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IFilesystemDo {
	return f.withDO(f.DO.Scopes(funcs...))
}

func (f filesystemDo) Unscoped() IFilesystemDo {
	return f.withDO(f.DO.Unscoped())
}

func (f filesystemDo) Create(values ...*models.Filesystem) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Create(values)
}

func (f filesystemDo) CreateInBatches(values []*models.Filesystem, batchSize int) error {
	return f.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (f filesystemDo) Save(values ...*models.Filesystem) error {
	if len(values) == 0 {
		return nil
	}
	return f.DO.Save(values)
}

func (f filesystemDo) First() (*models.Filesystem, error) {
	if result, err := f.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*models.Filesystem), nil
	}
}

func (f filesystemDo) Take() (*models.Filesystem, error) {
	if result, err := f.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*models.Filesystem), nil
	}
}

func (f filesystemDo) Last() (*models.Filesystem, error) {
	if result, err := f.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*models.Filesystem), nil
	}
}

func (f filesystemDo) Find() ([]*models.Filesystem, error) {
	result, err := f.DO.Find()
	return result.([]*models.Filesystem), err
}

func (f filesystemDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*models.Filesystem, err error) {
	buf := make([]*models.Filesystem, 0, batchSize)
	err = f.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (f filesystemDo) FindInBatches(result *[]*models.Filesystem, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return f.DO.FindInBatches(result, batchSize, fc)
}

func (f filesystemDo) Attrs(attrs ...field.AssignExpr) IFilesystemDo {
	return f.withDO(f.DO.Attrs(attrs...))
}

func (f filesystemDo) Assign(attrs ...field.AssignExpr) IFilesystemDo {
	return f.withDO(f.DO.Assign(attrs...))
}

func (f filesystemDo) Joins(fields ...field.RelationField) IFilesystemDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Joins(_f))
	}
	return &f
}

func (f filesystemDo) Preload(fields ...field.RelationField) IFilesystemDo {
	for _, _f := range fields {
		f = *f.withDO(f.DO.Preload(_f))
	}
	return &f
}

func (f filesystemDo) FirstOrInit() (*models.Filesystem, error) {
	if result, err := f.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*models.Filesystem), nil
	}
}

func (f filesystemDo) FirstOrCreate() (*models.Filesystem, error) {
	if result, err := f.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*models.Filesystem), nil
	}
}

func (f filesystemDo) FindByPage(offset int, limit int) (result []*models.Filesystem, count int64, err error) {
	result, err = f.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = f.Offset(-1).Limit(-1).Count()
	return
}

func (f filesystemDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = f.Count()
	if err != nil {
		return
	}

	err = f.Offset(offset).Limit(limit).Scan(result)
	return
}

func (f filesystemDo) Scan(result interface{}) (err error) {
	return f.DO.Scan(result)
}

func (f filesystemDo) Delete(models ...*models.Filesystem) (result gen.ResultInfo, err error) {
	return f.DO.Delete(models)
}

func (f *filesystemDo) withDO(do gen.Dao) *filesystemDo {
	f.DO = *do.(*gen.DO)
	return f
}
